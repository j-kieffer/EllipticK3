
/* Type definitions */

declare type EllK3;
declare attributes EllK3: EC, // Elliptic curve over univariate function field
        RedFib, // List of EllK3RedFib
        RootConf, // e.g, A2+D7

        Frame, // Even positive-definite lattice
        RootSpan, // Intersection with span of roots
        RootLat, // Sublattice generated by roots

        TorsGrp, // Obtained as lattice quotient
        TorsMap, // From RootNSLat
        TorsSections, // Listing all elements of torsion subgroup

        MWGrp, // Obtained as lattice quotient
        MWMap, // From NSLat
        MWLat, // Orthogonal projection, in same ambient space
        MWProj, // From ambient space, as a matrix
        MWSections; // Generators of known MW group

declare type EllK3RedFib;
declare attributes EllK3RedFib: Pl, // Place (irreducible polynomial or zero)
        Kodaira, // Kodaira type as string
        Fld, // Field of definition of components
        Comps; // Fiber components

declare type EllK3MW;
declare attributes EllK3MW: Vec, // in Néron--Severi lattice
        Pt; // On generic fiber as PtEll


/* Attributes of EllK3 */

intrinsic EllipticCurve(S :: EllK3) -> CrvEll
{Generic fiber of S as an elliptic curve.}
    require assigned S`EC: "Elliptic curve not assigned";
    return S`EC;
end intrinsic;

intrinsic ReducibleFibers(S :: EllK3) -> SeqEnum[EllK3RedFib]
{List of reducible fibers of S}
    require assigned S`RedFib: "Reducible fibers not assigned";
    return S`RedFib;
end intrinsic;

intrinsic RootConfiguration(S :: EllK3) -> GrpAbElt
{Configuration of root lattices of S}
    require assigned S`RootConf: "Root configuration not assigned";
    return S`RootConf;
end intrinsic;

intrinsic Frame(S :: EllK3) -> Lat
{Essential part of Néron--Severi lattice of S}
    require assigned S`Frame: "Néron--Severi lattice not assigned";
    return S`Frame;
end intrinsic;

intrinsic NeronSeveriRootSpan(S :: EllK3) -> Lat
{Part of Néron--Severi lattice of S contained in the span of roots}
    require assigned S`RootSpan: "Néron--Severi lattice not assigned";
    return S`RootSpan;
end intrinsic;

intrinsic RootLattice(S :: EllK3) -> Lat
{Root part of Néron--Severi lattice of S}
    require assigned S`RootLat: "Néron--Severi lattice not assigned";
    return S`RootLat;
end intrinsic;

intrinsic TorsionGroup(S :: EllK3) -> GrpAb, Map
{Known torsion part of Mordell--Weil group of S, and quotient map from root
part of Néron--Severi lattice}
    require assigned S`TorsGrp: "Torsion group not assigned";
    return S`TorsGrp, S`TorsMap;
end intrinsic;

intrinsic TorsionSections(S :: EllK3) -> SeqEnum[EllK3MW]
{List of all known torsion sections of S}
    require assigned S`TorsSections: "Torsion sections not assigned";
    return S`TorsSections;
end intrinsic;

intrinsic MordellWeilGroup(S :: EllK3) -> GrpAb, Map
{Known Mordell-Weil group of S, and quotient map from Néron--Severi lattice}
    require assigned S`MWGrp: "Mordell--Weil group not assigned";
    return S`MWGrp, S`MWMap;
end intrinsic;

intrinsic MordellWeilLattice(S :: EllK3) -> Lat, ModMatFldElt
{Known Mordell--Weil lattice of S, and orthogonal projection from ambient space
of Néron--Severi lattice}
    require assigned S`MWLat: "Mordell--Weil lattice not assigned";
    require assigned S`MWProj: "Orthogonal projection not assigned";
    return S`MWLat, S`MWProj;
end intrinsic;

intrinsic MordellWeilSections(S :: EllK3) -> SeqEnum[EllK3MW]
{List of generators for the free part of known Mordell--Weil group of S}
    require assigned S`MWSections: "Mordell--Weil sections not assigned";
    return S`MWSections;
end intrinsic;


/* Easy intrinsics for EllK3 */

intrinsic BaseFunctionField(S :: EllK3) -> Fld
{Function field on the base P^1 for the elliptic K3 surface S}
    return BaseField(EllipticCurve(S));
end intrinsic;

intrinsic BaseField(S :: EllK3) -> Fld
{Base field of the elliptic K3 surface}
    return BaseField(BaseFunctionField(S));
end intrinsic;

intrinsic EllipticParameter(S :: EllK3) -> RngUPolElt
{Elliptic parameter of S, as an element of a univariate polynomial ring}
    F := BaseFunctionField(S);
    return Numerator(F.1);
end intrinsic;

intrinsic PolynomialRing(S :: EllK3) -> RngUPol
{Polynomial ring in elliptic parameter of S}
    return Parent(EllipticParameter(S));
end intrinsic;

intrinsic aInvariants(S :: EllK3) -> SeqEnum[RngUPolElt]
{a-invariants of the elliptic K3 surface}
    return [Numerator(c): c in aInvariants(EllipticCurve(S))];
end intrinsic;

intrinsic Coefficients(S :: EllK3) -> SeqEnum[RngUPolElt]
{Coefficients a2, a4, a6 of elliptic K3 surface}
    ai := aInvariants(S);
    return [ai[2], ai[4], ai[5]];
end intrinsic;

intrinsic cInvariants(S :: EllK3) -> SeqEnum[RngUPolElt]
{c-invariants of the elliptic K3 surface}
    return [Numerator(c): c in cInvariants(EllipticCurve(S))];
end intrinsic;

intrinsic Discriminant(S :: EllK3) -> RngUPolElt
{Discriminant of the elliptic K3 surface}
    return Numerator(Discriminant(EllipticCurve(S)));
end intrinsic;

intrinsic RHS(S :: EllK3, x :: RngElt) -> RngElt
{Return right hand side of elliptic surface equation, evaluated at x}
    a2,a4,a6 := Explode(Coefficients(S));
    return x^3+a2*x^2+a4*x+a6;
end intrinsic;

intrinsic FrameSpace(S :: EllK3) -> ModTupFld
{Ambient space of Néron--Severi lattice of S}
    return AmbientSpace(Frame(S));
end intrinsic;

intrinsic NeronSeveriRank(S :: EllK3) -> RngIntElt
{Rank of known Néron--Severi lattice of S}
    return Rank(Frame(S)) + 2;
end intrinsic;

intrinsic MordellWeilRank(S :: EllK3) -> RngIntElt
{Mordell--Weil rank of S}
    return Rank(MordellWeilLattice(S));
end intrinsic;


/* Attributes for EllK3RedFib */

intrinsic Place(fib :: EllK3RedFib) -> RngUPolElt
{Place of reducible fiber as irreducible polynomial or zero (place at infinity)}
    require assigned fib`Pl: "Place not assigned";
    return fib`Pl;
end intrinsic;

intrinsic KodairaType(fib :: EllK3RedFib) -> MonStgElt
{Kodaira type of reducible fiber}
    require assigned fib`Kodaira: "Kodaira type not assigned";
    return fib`Kodaira;
end intrinsic;

intrinsic FieldOfRationality(fib :: EllK3RedFib) -> Fld
{True iff reducible fiber components are defined over the base field}
    require assigned fib`Fld: "Field not assigned";
    return fib`Fld;
end intrinsic;

intrinsic Components(fib :: EllK3RedFib) -> SeqEnum[SeqEnum[RngUPolElt]]
{Simple components of reducible fiber}
    require assigned fib`Comps: "Components not assigned";
    return fib`Comps;
end intrinsic;


/* Easy intrinsics for EllK3RedFib */

intrinsic RootType(fib :: EllK3RedFib) -> GrpAbElt
{Root type of reducible fiber}
    return RootLatticeType(KodairaType(fib));
end intrinsic;

intrinsic RootLattice(fib :: EllK3RedFib) -> Lat
{Root lattice attached to reducible fiber}
    return RootLattice(KodairaType(fib));
end intrinsic;

intrinsic Component(fib :: EllK3RedFib, i :: RngIntElt) -> SeqEnum[RngUPolElt]
{Simple component number i of reducible fiber}
    return Components(fib)[i];
end intrinsic;


/* Attributes for EllK3MW */

intrinsic NSVector(x :: EllK3MW) -> LatElt
{Néron--Severi vector attached to x}
    //require assigned v`Vec: "Vector not assigned";
    return x`Vec;
end intrinsic;

intrinsic Section(x :: EllK3MW) -> PtEll
{Return x as point on generic fiber of elliptic K3 surface}
    require assigned x`Pt: "Coordinates not assigned";
    return x`Pt;
end intrinsic;


/* Easy intrinsics for EllK3MW */

intrinsic Coordinates(x :: EllK3MW) -> SeqEnum[FldFunElt]
{Return coordinates (x:y:z) of Mordell--Weil section}
    return Coordinates(Section(x));
end intrinsic;

intrinsic xCoordinate(x :: EllK3MW) -> FldFunElt
{Return affine x-coordinate of Mordell--Weil section}
    w, _, z := Explode(Coordinates(x));
    return w/z;
end intrinsic;

intrinsic yCoordinate(x :: EllK3MW) -> FldFunElt
{Return affine y-coordinate of Mordell--Weil section}
    _, y, z := Explode(Coordinates(x));
    return y/z;
end intrinsic;


/* Print functions */

intrinsic Print(S :: EllK3)
{Print S}
    printf "Elliptic K3 surface with parameter %o and coefficients\n",
           EllipticParameter(S);
    c := Coefficients(S);
    printf "a2 = %o\n", c[1];
    printf "a4 = %o\n", c[2];
    printf "a6 = %o\n", c[3];
    printf "over %o", BaseField(S);
end intrinsic;

intrinsic Print(fib :: EllK3RedFib)
{Print fib}
    if Place(fib) eq 0 then
        printf "Reducible fiber at t = Infinity";
    else
        printf "Reducible fiber at %o = 0", Place(fib);
    end if;
    printf " of Kodaira type %o", KodairaType(fib);
end intrinsic;

intrinsic Print(x :: EllK3MW)
{Print x}
    printf "Mordell--Weil section with coordinates";
    printf "x = %o", xCoordinate(x);
    printf "y = %o", yCoordinate(x);
    printf "Néron--Severi vector: %o", NSVector(x);
end intrinsic;
